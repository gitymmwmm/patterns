# Реконсиляция (reconciliation) в React — подробное и проверенное объяснение

> Цель: структурировать, уточнить и расширить ваши мысли про реконсиляцию, Fiber, WIP/CT, эвристики и поведение при работе со списками (ключи vs индекс). Примеры и диаграммы — чтобы было видно, **почему** элементы *сохраняются*, *перемещаются* или *ремонтируются/удаляются*.

---

## 1. Краткое резюме

Реконсиляция — это процесс, при котором React сравнивает **новое** представление компонента (новый VDOM, *work‑in‑progress* — WIP) с **текущим** (CT, текущий VDOM / текущая Fiber-структура) и на основании отличий формирует минимальный набор операций (эффектов) для реального DOM и жизненных циклов. В React этот процесс реализован через **Fiber**: сначала выполняется **render (reconciliation) phase** — строится WIP‑дерево и помечаются эффекты, затем **commit phase** — эффекты применяются в DOM синхронно.

---

## 2. Терминология (коротко и чётко)

* **VDOM / React Element** — декларативное описание элемента/компонента (JSX → объект).
* **Current tree (CT)** — дерево Fiber/элементов, которое отражает состояние послeднего коммита.
* **Work‑in‑Progress (WIP)** — дерево, которое React строит в render‑фазе для нового состояния.
* **Fiber** — внутренний объект (узел), который хранит связь между элементом, состоянием, эффектами, ссылками на детей/братьев/родителя.
* **Render (reconciliation) phase** — вычисление WIP и списка эффектов (может быть прерван/пауза).
* **Commit phase** — атомарное применение эффектов: монтирование, размонтирование, обновление DOM, вызов `componentDidMount`/`componentWillUnmount` и пр.

---

## 3. Основные эвристики, которые использует React (и которые вы правильно перечислили)

React применяет набор эвристик чтобы снизить сложность сравнения деревьев с теоретически экспоненциальной до линейной:

1. **Тип элемента** — если тип поменялся (например `div` → `span`, или компонент `A` → `B`), React считается, что поддерево изменилось: старое размонтируется, новое смонтируется.
2. **Ключ (`key`)** — если у элементов есть `key`, React использует его как стабильную идентичность: одинаковые ключи = та же сущность (при прочих равных), ключи позволяют корректно опознать перемещения/вставки/удаления без дорогостоящего полного сравнения.
3. **Позиция (siblings order / индекс)** — когда `key` отсутствует, React использует позиционную стратегию (сопоставляет по индексу / положению). Это обходной путь, но он даёт линейную сложность.

Эти три фактора (состояние/момент времени — т.е. текущая snapshot‑версия дерева, тип и ключ) — именно то, что вы перечислили. Формулировка требует уточнений: не «если без ключа элемент изменил позицию — он сразу уничтожается» — правильнее: **без ключа React сопоставляет элементы по позиции**, поэтому при вставке/удалении раньше в списке элементы «сдвигаются» и их содержимое/instance будет переиспользовано на новых позициях (а не «перемещено» как в случае с ключами). Это выглядит как «старый элемент уничтожен, новый создан» с точки зрения логической идентичности данных, но **фактически** React часто просто **апдейтит** узел по позиции, что приводит к смене ассоциированного состояния между элементами.

---

## 4. Как именно React сравнивает (в общих чертах, шаги алгоритма для детей‑массива)

(Упрощённая, но точная по смыслу схема, близкая к тому, что реализовано в `reconcileChildFibers`)

1. **Линейный проход слева направо**: React начинает сравнивать детей по порядку. Пока `type` и `key` совпадают — узлы *повторно используются* (reuse) и рекурсия идёт глубже.
2. **Линейный проход справа налево**: симметричная проверка с конца (оптимизация для случаев, когда вставки в середину редки).
3. **Оставшиеся — промежуток**: если в середине произошли изменения (вставки/удаления/перестановки), React строит карту (map) из оставшихся старых детей по ключам и затем для каждого нового элемента в этом промежутке:
   * если у нового есть `key` и он найден в map — React **перебрасывает** старый fiber для этой сущности (тем самым сохраняет состояние и DOM), помечает этот узел на перемещение;
   * если нет ключа или ключа нет в map — создаётся новый fiber (mount);
4. **Удаление оставшихся старых узлов**, которые не были перераспределены.

Эти шаги дают амортизированную **O(n)** по числу детей: сравнение с начала/конца и построение карты для средины — основная идея, как React упростил задачу от потенциально экспоненциальной до линейной. (Официально это описано в документации как «эвристики, которые снижают O(n^3) → O(n)»).

---

## 5. Правила сохранения/удаления/перемещения — коротко и практично

* **Если `type` отличается** → старый fiber размонтируется, новый монтируется (полная замена).
* **Если `key` совпадает и `type` совпадает** → React **сохраняет** инстанс/состояние и DOM (перемещение/переупорядочивание так же сохранит state).
* **Если `key` отсутствует** → React сопоставляет по **позиции**: элемент на позиции `i` старого списка будет использован для элемента на позиции `i` нового списка (если `type` совместим). Это приводит к «сдвигу состояний» при вставках/удалениях.

---

## 6. Разбор вашей формулировки и уточнения (включая п.1 и п.2 в вашем первоначальном тексте)

### Ваша формулировка (п.1):

> "Если в новом состоянии дерева элемент без ключа изменил свою позицию (рассматриваем на уровне siblings) относительно старого положения от начала, не имея при этом ключа, то он уничтожается, если сохранил, то он обновляется."

**Уточнение:** React **неявно полагается на позицию**. При сдвиге без ключей React просто продолжит обновлять узлы по позиции. Следствие: *идентичность* сущности фактически изменится (потеряется корректная привязка state к сущности), но React не «специально ищет и уничтожает прежнюю инстанс» — он переиспользует узлы по индексам. То есть:

* Элемент, который «перешёл» в новую позицию — не будет найден как тот же логический объект (так как нет ключа), и состояние может «упасть» на другой элемент;
* React **не выполняет expensive search** для поиска перемещённой без ключа сущности, поэтому с точки зрения экземпляров — поведение выглядит как «старое размонтировали/новое смонтировали», но технически это было реализовано через обновление узлов по индексам и удаление лишних в конце.

### Ваша формулировка (п.2):

> "Если при этом у него был ключ, то реакт не будет его удалять..., сохранит DOM ноды, сохранит состояние компонента и переместит их на новую позицию в списке дочерних элементов."

**Подтверждение и доп. детали:** да — именно так. Ключ — это **фактическая идентичность** элемента внутри списка. При совпадающем ключе React сохранит fiber/instance и просто пометит его на перемещение (в commit‑фазе DOM‑узлы физически переместятся), состояние сохранится.

---

## 7. Отвечаю прямо на ваш конкретный вопрос про N и предпоследний элемент

> **Вопрос:** если есть список из N элементов и мы удаляем элемент с предпоследнего положения, почему последний элемент *не размонтируется*?

Нужно разобрать аккуратно — здесь важны два понятия: *размонтируется конкретный старый экземпляр* и *визуально элемент останется в DOM*. Поясню на конкретном примере.

**Пример (без `key`):**

Состояние до (old, индексы):

```
index: 0   1   2   3
value: A   B   C   D
```

Удаляем `C` (индекс 2). Новое состояние (new):

```
index: 0   1   2
value: A   B   D
```

Алгоритм (упрощённо):

1. Сравниваем индекс 0: `A` vs `A` → reuse (тот же fiber в позиции 0).
2. Индекс 1: `B` vs `B` → reuse.
3. Индекс 2: **старый** в этой позиции — `C`, **новый** — `D`. Поскольку ключей нет, React смотрит на тип/положение: если `type` совместим (например оба `<li>` или оба однотипные элементы), React **обновит** fiber на позиции 2 (т.е. старый fiber для `C` перезапишет/переиспользуется для рендеринга `D`).
4. Остался старый элемент в позиции 3 (`D` старый), но в новом массиве на позиции 3 элемента нет — он помечается на удаление и будет размонтирован в commit‑фазе.

**Итог:** визуально элемент `D` останется в списке (он покажется как последний в новом списке), но **это не тот же самый экземпляр/DOM‑узел, что был раньше**: новое отображение `D` будет рендериться в DOM‑узле, который раньше обслуживал `C`. Старый DOM‑узел, который раньше был `D` (index 3), будет размонтирован.

Поэтому удобная и краткая формулировка ответа: **последний видимый элемент в новом списке не размонтируется визуально, потому что React без ключей переиспользует узел на той позиции, куда "сдвинулись" элементы; но конкретный старый экземпляр, который раньше был в конце, будет размонтирован — просто отображение сохраняется за счёт переиспользования позиции.**

Если же у элементов были бы **ключи**, то React нашёл бы `D` по ключу, **переместил бы его fiber** на новую позицию и **не размонтировал бы старый экземпляр `D`** — state и DOM были бы сохранены именно для `D`.

---

## 8. Практические следствия и рекомендации (Senior‑level)

1. **Всегда давайте стабильные `key` для списков с изменяемым порядком** (id из данных). Это гарантирует, что идентичность сущности сохранится при перестановках.
2. **Не используйте индекс массива как `key`**, если порядок может меняться (удаления/вставки/сортировка) — индекс годится только для статичных списков или когда элементы никогда не перемещаются и не удаляются.
3. **Будьте осторожны с контролируемыми input'ами и local state** внутри элементов списка: без ключей state может «перескочить» на другой элемент при вставке/удалении.
4. **Если нужно принудительно размонтировать/пересоздать компонент** — поменяйте `key`. Это явный и безопасный способ сброса состояния компонента.
5. **Понимайте, когда render‑фаза может быть прервана (Fiber)**: не делайте побочных эффектов в render (а только в commit‑фазе / lifecycle / effects).

---

## 9. Быстрая шпаргалка (коротко)

* `type` ≠ → replace (unmount + mount).
* `key` совпадает + `type` совпадает → reuse & preserve state (move).
* нет `key` → positional matching (reuse by index → risk of state switching).
* render = вычисление и пометка эффектов (может быть прерван), commit = применение и вызов side‑effects (синхронно).

---

## 10. Хотите примеры кода и live‑демо? (что я могу добавить в файл по‑вашему запросу)

* Минимальные JSX‑примеры, показывающие поведение без ключей (включая input с value и сохранение состояния).
* Три варианта: без ключей, с ключами (id), с ключами = индекс (показывая разницу).
* Псевдокод `reconcileChildFibers` (упрощённая реализация), чтобы было видно `left-to-right`, `right-to-left`, `map` шаги.

---

## 11. Заключение

Ваше понимание в целом корректно: вы описали ключевые факторы (состояние дерева, тип, ключ) и роль Fiber. Я уточнил формулировки про поведение при отсутствии ключей и детально разобрал сценарий с удалением предпоследнего элемента. Главное правило: **ключи = идентичность**, без ключей — позиция = идентичность (и это источник всех «странных» переносов состояния).

---

## 12. Дополнение: минимальные демонстрации (JSX) — поведение списков

Ниже — три маленьких примера, которые можно вставить в CRA/CodeSandbox и наблюдать поведение (вставка/удаление, input'ы с локальным состоянием).

1) Без ключей (показывает "перескакивание" state):

```jsx
function Item({label}) {
  const [val, setVal] = React.useState('');
  return (
    <li>
      <div>{label}</div>
      <input value={val} onChange={e => setVal(e.target.value)} placeholder="local state" />
    </li>
  );
}

function AppNoKeys() {
  const [items, setItems] = React.useState(['A','B','C','D']);
  return (
    <div>
      <button onClick={() => setItems(prev => prev.filter((_,i) => i !== 2))}>Remove index 2</button>
      <ul>
        {items.map((it) => <Item label={it} />)}
      </ul>
    </div>
  );
}
```

2) С ключами = stable id (правильно сохраняет state и DOM):

```jsx
function AppWithKeys() {
  const [items, setItems] = React.useState([
    {id: 'a', name: 'A'},
    {id: 'b', name: 'B'},
    {id: 'c', name: 'C'},
    {id: 'd', name: 'D'},
  ]);
  return (
    <div>
      <button onClick={() => setItems(prev => prev.filter(x => x.id !== 'c'))}>Remove C</button>
      <ul>
        {items.map(it => <Item key={it.id} label={it.name} />)}
      </ul>
    </div>
  );
}
```

3) С ключами = индекс (опасно при изменении порядка):

```jsx
function AppIndexKeys() {
  const [items, setItems] = React.useState(['A','B','C','D']);
  return (
    <div>
      <button onClick={() => setItems(prev => prev.filter((_,i) => i !== 1))}>Remove index 1</button>
      <ul>
        {items.map((it, i) => <Item key={i} label={it} />)}
      </ul>
    </div>
  );
}
```

Откройте каждый пример и введите текст в input'ы для элементов, затем удалите элемент и посмотрите, как тексты "перескакивают" между строками — это прямой эффект positional matching без ключей/при использовании индекса.

---

## 13. Псевдокод (упрощённый) — как работает reconcileChildFibers

```text
function reconcileChildren(oldList, newList):
  // 1. scan from left while same type & key
  left = 0
  while left < oldList.len and left < newList.len and same(oldList[left], newList[left]):
    reuse oldList[left] for newList[left]
    left++

  // 2. scan from right while same
  rightOld = oldList.len - 1
  rightNew = newList.len - 1
  while rightOld >= left and rightNew >= left and same(oldList[rightOld], newList[rightNew]):
    reuse oldList[rightOld] for newList[rightNew]
    rightOld--
    rightNew--

  // 3. now middle interval may contain moves/inserts/deletes
  if left <= rightOld and left <= rightNew:
    // build map of remaining old children by key or by index if no key
    map = buildMap(oldList[left..rightOld])
    for i from left to rightNew:
      newChild = newList[i]
      if newChild.key in map:
        matchedOld = map[newChild.key]
        reuse matchedOld for newChild (mark moved)
        remove matchedOld from map
      else:
        create new fiber for newChild (mount)

  // 4. delete any old nodes left in map
  delete remaining old fibers in map
```

Эта схема демонстрирует идеи: быстрые проверки (L→R и R→L) для общей части и O(k) map‑шаг для участка с перестановками/вставками.

---

## 14. Наглядная ASCII‑диаграмма (перемещение без ключей vs с ключами)

1) Без ключей (позиционное сопоставление):
```
old indices:  0:A 1:B 2:C 3:D
remove C (index 2)
new indices:  0:A 1:B 2:D
action:
- reuse node@0 -> A
- reuse node@1 -> B
- reuse node@2 (was C) -> render D  <-- state moves to different label
- remove node@3 (was D)
```

2) С ключами:
```
old keys: a:A b:B c:C d:D
remove c
new keys: a:A b:B d:D
action:
- reuse fiber with key 'a'
- reuse fiber with key 'b'
- find fiber with key 'd' in map -> move it to new position (preserve state & DOM)
- remove fiber with key 'c'
```

---

## 15. Как тестировать самостоятельно (быстро)

1. Создайте CRA или откройте CodeSandbox.
2. Вставьте пример `AppNoKeys`, `AppWithKeys`, `AppIndexKeys`.
3. Для каждого: введите текст в input элемента, затем удалите/вставьте элементы и наблюдайте.
4. Используйте React DevTools (Components) чтобы смотреть identity/fiber и state изменений.

---

## 16. Существующий ваш пример (оставляю без радикальных изменений) — для справки

```jsx
const App: React.FC = () => {
  const [interval, setInverval] = useState(() => ({
    x: 0,
    y: 100,
  }));

  // Проблемы с маунтингом <Cmp name="StaticEnd2" />, внутри списка он не имеет уникального ключа и по правилу сопоставления не срастается все
  // const remountStaticEnd2 = (
  //   <ul
  //     onContextMenu={(e) => (
  //       e.preventDefault(), setInverval(({ x, y }) => ({ x: --x, y }))
  //     )}
  //     onClick={() => setInverval(({ x, y }) => ({ x: ++x, y }))}
  //   >
  //     {[
  //       // interval.x > 2 &&
  //       <Cmp name="StaticStart" />,

  //       ...Data.slice(0, interval.x).map((x, i) => (
  //         <Cmp key={x} name={String(i)} />
  //       )),
  //       ,
  //       <Cmp name="StaticEnd2" />,
  //     ].filter(Boolean)}
  //   </ul>
  // );

  // Все нормально рисуется
  const ui = (
    <ul
      onContextMenu={(e) => (
        e.preventDefault(), setInverval(({ x, y }) => ({ x: --x, y }))
      )}
      onClick={() => setInverval(({ x, y }) => ({ x: ++x, y }))}
    >
      <Cmp name="StaticStart" />
      {[
        ...Data.slice(0, interval.x).map((x, i) => (
          <Cmp key={x} name={String(i)} />
        )),
      ].filter(Boolean)}
      <Cmp name="StaticEnd2" />
    </ul>
  );

  console.log({ ui });

  return ui;
};
```

Комментарий: в этом конкретном примере `StaticEnd2` остаётся стабильным в конце списка, потому что вы явно разместили его **после** массива, а не внутри неё. Если вы переместите его внутрь массива без ключа — поведение станет чувствительным к позиции.

---

## 17. Резюме и следующие шаги

Я дополнил ваш текст примерами, псевдокодом и краткими рекомендациями для самостоятельного тестирования. Если хотите, я:

- могу подготовить ZIP с этим `.md` файлом и выдать ссылку на скачивание;
- либо выложить файл в новый репозиторий в вашем аккаунте `gitymmwmm` (нужны права/подтверждение) и прислать прямую ссылку;
- либо создать публичный Gist с этим `.md` (требуется подтверждение).

Напишите, как предпочитаете получить файл: "ZIP" / "репозиторий в моём аккаунте" / "Gist" — и я выполню следующий шаг.

---